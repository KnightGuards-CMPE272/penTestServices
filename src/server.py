from flask import Flask
from flask_cors import CORS
from flask import request
import subprocess
import platform
import paramiko
import socket
import ssl
import helper
import nmap3
import json
import db 
import os
from bson import ObjectId, json_util
from datetime import datetime
import requests
import configparser
import time
import helper
from zapv2 import ZAPv2
server = Flask(__name__)
cors = CORS(server, resources={r"/*": {"origins": "*"}})


class JSONEncoder(json.JSONEncoder):
    def default(self, o):
         if isinstance(o, ObjectId):
            return str(o)
         if isinstance(o, datetime):
            return str(o)
         return json.JSONEncoder.default(self, o)



@server.route("/zap/spider/<host>")
def zap_spider(host):
    # The URL of the application to be tested
    # Change to match the API key set in ZAP, or use None if the API key is disabled
    config = configparser.ConfigParser()
    config.read('config.ini')
    target = "https://" + host
    apiKey = None
    http_proxy = ''
    https_proxy = ''
    if 'ZAP' in config:
      vm_def = config['ZAP']
      if config.has_option('ZAP', 'apiKey'):
          apiKey = vm_def['apiKey']
      else:
          return "ZAP API Key not configured"
      if config.has_option('ZAP', 'http_proxy') and config.has_option('ZAP', 'https_proxy'):
          http_proxy = vm_def['http_proxy']
          https_proxy = vm_def['https_proxy']
      else:
          http_proxy = ""
          https_proxy = ""

    # By default ZAP API client will connect to port 8080
    if not http_proxy and not https_proxy:
        zap = ZAPv2(apikey=apiKey)
    else:
        zap = ZAPv2(apikey=apiKey, proxies={'http': http_proxy, 'https': https_proxy})

    print('Spidering target {}'.format(target))
    # The scan returns a scan id to support concurrent scanning
    scanID = zap.spider.scan(target)
    while int(zap.spider.status(scanID)) < 100:
        # Poll the status until it completes
        print('Spider progress %: {}'.format(zap.spider.status(scanID)))
        time.sleep(1)

    print('Spider has completed!')
    # The URLs the spider has crawled
    print('\n'.join(map(str, zap.spider.results(scanID))))
    return str(zap.spider.results(scanID))

@server.route("/http_req/<host>")
def http_req(host):
    print("Host: " + host)
    r = requests.get("http://"+host)
    print("Status Code: ", r.status_code)
    print("Headers: ", r.headers)
    #print("Content: ", r.text)
    if r.status_code >= 200 and r.status_code <= 299:
        return str(r.headers)
    else:
        return "Unsuccessful Response"

@server.route("/ssl_crypto/<host>")
def ssl_crypto(host):
   hostname = host
   process = subprocess.Popen(['./ssl_crypto.sh', hostname], 
                           stdout=subprocess.PIPE,
                           universal_newlines=True)
   while True:
      output = process.stdout.readline()
      print(output.strip())
      finaloutput = output +"<br>"
      # Do something else
      return_code = process.poll()
      if return_code is not None:
         print('RETURN CODE', return_code)
         # Process has finished, read rest of the output 
         for output in process.stdout.readlines():
               finaloutput = finaloutput + output.strip() +"<br>"
      return "Available Cryptos:\r\n"+finaloutput

@server.route("/ssl_version/<host>")
def ssl_version(host):
   hostname = host
   context = ssl.create_default_context()
   with socket.create_connection((hostname, 443)) as sock:
       with context.wrap_socket(sock, server_hostname=hostname) as ssock:
           return ssock.version()

@server.route("/ping/<host>")
def ping(host):
   #windows ping is ping -n 1 while POSIX is ping -c
   param = '-n' if platform.system().lower()=='windows' else '-c'
   # Building the command. Ex: "ping -c 1 google.com"
   command = ['ping', param, '1', host]
   ret = ""
   if subprocess.call(command) == 0:
       ret = "Host is Pingable"
       pass
   else:
       ret = "Host is not Pingable"
       pass
   return ret

@server.route("/rpc_info/<host>")
def rpcinfo(host):
   return json.dumps(helper.rpcServiceInfo(host))

@server.route("/scan/<host>")
def nmap(host):
   nmap = nmap3.Nmap()
   time.sleep(10)
   version_result = nmap.nmap_version_detection(host)
   
   print("Version Result:")
   print(version_result)
   
   if (version_result):
      print("Inside Scan results")
      file = open('scanresults.json', 'w+')
      jsonResult = json.dumps(version_result)
      file.write(jsonResult)
      file.close()
   else:
      file = open('scanresults.json','r')
      jsonResult = file.read()
   
   responseDict  = eval(jsonResult)
   resultKeys = list(responseDict.keys())
   resultDict = {}
   resultDict['hostname'] = resultKeys[0]
   resultDict['scannedResult'] = responseDict[resultKeys[0]]
   now = datetime.now()
   resultDict['scannedDate'] = now.strftime("%m/%d/%Y, %H:%M:%S")
   resultDict['rpcInfo'] = helper.rpcServiceInfo(host)
   print(resultDict)
   
   mongoObj = resultDict.copy()
   if os.getenv('MONGO'):
      id=db.storeScanResult(mongoObj)
      print("Id:"+str(id))  
      
   return json.dumps(resultDict)

@server.route("/scannedresults/<limit>")
def getScannedResults(limit):
   if os.getenv('MONGO'):
      results = db.getScanResult(limit)
      json_docs = []
      for doc in results:
         json_docs.append(doc)
         print(json_docs)
         #finalResult = json.dumps(JSONEncoder().encode(json_docs))
         finalResult = json.dumps(json_docs,default=json_util.default)
         file = open('scanresults_all.json', 'w+')
         file.write(finalResult)
         file.close() 
   else:
      file = open('scanresults_all.json','r')
      finalResult = file.read()
      
   return finalResult

@server.route("/scanresult/<id>")
def getScanResult(id):
   if os.getenv('MONGO'):  
      results = db.getSingleScanResult(id)
      print(results)
      #finalResult = json.dumps(JSONEncoder().encode(json_docs))
      finalResult = json.dumps(results,default=json_util.default)
      file = open('scanresults_one.json', 'w+')
      file.write(finalResult)
      file.close() 
   else:
      file = open('scanresults_one.json','r')
      finalResult = file.read()
      
   return finalResult

@server.route("/kaaliscan/<host>")
def scan(host):
   config = configparser.ConfigParser()
   config.read('config.ini')
   hostname = ''
   username = ''
   password = ''
   if 'kali' in config:
     vm_def = config['kali']
     hostname = vm_def['hostname']
     username = vm_def['username']
     password = vm_def['password']

   toBeScanned = host
   commands = [
    #"pwd",
    "timeout 180s msfconsole -q -x 'nmap -sV "+toBeScanned+"'; exit;"
    #"ls -l"
    ]
   
   client = paramiko.SSHClient()
   # add to known hosts
   client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
   try:
      client.connect(hostname=hostname, username=username, password=password)
   except:
      print("[!] Cannot connect to the SSH Server")
      exit()
   output = '<br>Scanning all ports in host:<br>'
   for command in commands:
     print("="*50, command, "="*50)
     stdin, stdout, stderr = client.exec_command(command)
     lineoutput = stdout.read().decode()+"<br>"
     #lineoutput = lineoutput.replace('\n','<br>')
     print(lineoutput)
     output = output + lineoutput
     err = stderr.read().decode()
     if err:
      print(err)
   print("*********************************************")
   #helper.parseOutput(output)
   print("*********************************************")
   return output
   

@server.route("/")
def hello():
   return "Hello World!"

if __name__ == "__main__":
   server.run(host='0.0.0.0', port=4999, debug=True)
